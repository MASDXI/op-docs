---
title: OP Stack Components
description: Learn about the modular components that make up the OP Stack.
---

# OP Stack Components

The OP Stack is built as a modular system with interchangeable components. Understanding these components is key to working with the OP Stack.

## Architecture Overview

The OP Stack consists of several layers, each with specific responsibilities:

<CardGroup cols={2}>
  <Card title="Data Availability Layer" icon="database">
    Handles how transaction data is stored and made available
  </Card>
  <Card title="Sequencing Layer" icon="list">
    Manages the ordering and batching of transactions
  </Card>
  <Card title="Derivation Layer" icon="arrow-right">
    Processes L1 data to derive the L2 state
  </Card>
  <Card title="Execution Layer" icon="play">
    Executes transactions and maintains state
  </Card>
  <Card title="Settlement Layer" icon="check">
    Finalizes transactions and handles dispute resolution
  </Card>
  <Card title="Governance Layer" icon="users">
    Manages protocol upgrades and parameter changes
  </Card>
</CardGroup>

## Core Components

### Rollup Node (op-node)

The rollup node is the consensus client for OP Stack chains:

<Accordion title="Key Functions">
- **Block Derivation**: Derives L2 blocks from L1 data
- **State Validation**: Validates proposed state transitions
- **P2P Networking**: Communicates with other nodes
- **Unsafe Block Production**: Produces blocks from mempool transactions
</Accordion>

### Execution Engine (op-geth)

The execution engine processes transactions and maintains state:

<Accordion title="Key Functions">
- **Transaction Processing**: Executes smart contracts and transactions
- **State Management**: Maintains the current state of the blockchain
- **RPC Interface**: Provides JSON-RPC API for applications
- **Block Production**: Builds blocks from transaction pools
</Accordion>

### Batcher

The batcher submits transaction data to L1:

<Accordion title="Key Functions">
- **Data Compression**: Compresses transaction data for efficiency
- **L1 Submission**: Submits compressed data to L1 smart contracts
- **Cost Optimization**: Optimizes for L1 gas costs
- **Reliability**: Ensures data availability on L1
</Accordion>

### Proposer

The proposer submits state root proposals to L1:

<Accordion title="Key Functions">
- **State Root Calculation**: Computes state roots for L2 blocks
- **L1 Submission**: Submits state root proposals to L1
- **Finality**: Enables withdrawal finalization
- **Dispute Resolution**: Participates in fault proof system
</Accordion>

## Modular Design

### Benefits of Modularity

- **Flexibility**: Swap components based on requirements
- **Upgradability**: Upgrade individual components independently
- **Customization**: Customize specific layers for use cases
- **Innovation**: Experiment with new implementations

### Component Interfaces

Each layer has well-defined interfaces:

```typescript
interface DataAvailabilityLayer {
  publishData(data: bytes): Promise<void>;
  retrieveData(reference: string): Promise<bytes>;
}

interface SequencingLayer {
  submitTransaction(tx: Transaction): Promise<void>;
  getBlockTemplate(): Promise<BlockTemplate>;
}
```

## Alternative Implementations

### Data Availability Alternatives

<CardGroup cols={2}>
  <Card title="Ethereum DA" icon="ethereum">
    Use Ethereum L1 for data availability (default)
  </Card>
  <Card title="Celestia DA" icon="star">
    Use Celestia for cheaper data availability
  </Card>
  <Card title="EigenDA" icon="layers">
    Use EigenLayer's data availability solution
  </Card>
  <Card title="Custom DA" icon="cog">
    Implement custom data availability solution
  </Card>
</CardGroup>

### Execution Alternatives

<CardGroup cols={2}>
  <Card title="EVM" icon="code">
    Standard Ethereum Virtual Machine (default)
  </Card>
  <Card title="Alt-VM" icon="cpu">
    Alternative virtual machines (experimental)
  </Card>
</CardGroup>

## Configuration

### Chain Configuration

```json
{
  "genesis": {
    "l1": {
      "hash": "0x...",
      "number": 12345
    },
    "l2": {
      "hash": "0x...",
      "number": 0
    }
  },
  "block_time": 2,
  "seq_window_size": 3600,
  "max_seq_drift": 600
}
```

### Node Configuration

```yaml
# Rollup configuration
rollup:
  l1_rpc: "https://ethereum-rpc"
  l2_rpc: "http://op-geth:8545"
  
# Execution configuration
execution:
  engine_endpoint: "http://op-geth:8551"
  jwt_secret: "/path/to/jwt-secret"
```

## Development and Testing

### Local Development

<Steps>
  <Step title="Install Dependencies">
    Set up the required development tools
  </Step>
  <Step title="Configure Environment">
    Set up configuration files for local testing
  </Step>
  <Step title="Start Components">
    Launch all necessary components
  </Step>
  <Step title="Test Interactions">
    Verify component interactions work correctly
  </Step>
</Steps>

### Testing Tools

<CardGroup cols={2}>
  <Card title="Supersim" href="/interop/tools/supersim" icon="play">
    Multi-chain development environment
  </Card>
  <Card title="Devnet" href="https://devnets.optimism.io" icon="globe">
    Hosted development networks
  </Card>
</CardGroup>

## Best Practices

### Component Selection

1. **Requirements Analysis**: Understand your specific needs
2. **Performance Evaluation**: Test different implementations
3. **Security Assessment**: Evaluate security implications
4. **Maintenance Considerations**: Consider long-term maintenance

### Configuration Management

1. **Version Control**: Track configuration changes
2. **Environment Separation**: Use different configs for different environments
3. **Documentation**: Document configuration choices
4. **Validation**: Validate configurations before deployment

## Next Steps

<CardGroup cols={2}>
  <Card title="Deploy a Chain" href="/operators/chain-operators" icon="rocket">
    Learn how to deploy your own OP Stack chain
  </Card>
  <Card title="Beta Features" href="/stack/beta-features" icon="flask">
    Explore experimental OP Stack features
  </Card>
</CardGroup> 