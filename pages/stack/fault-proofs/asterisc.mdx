---
title: Asterisc
lang: en-US
description: Learn about Asterisc
---
# Asterisc

[Asterisc](https://github.com/protolambda/asterisc/tree/master) is an alternative fault-proof VM for the OP Stack, crafted to validate RISC-V program execution via an interactive fraud-proof mechanism. Asterisc bridges simplicity and functionality, delivering a minimalist yet powerful solution for optimistic rollup fraud-proofing. Leveraging the RISC-V architecture, it offers:

- Support for 64-bit operations
- Concurrent yet deterministic threading
- Compatibility with RISC-V’s expanding ecosystem

Read more about fault-proofs in our [Fault-proof explainer](/stack/fault-proofs/explainer)

## How it works

Asterisc enables parties to reach consensus on shared execution trace states. In cases of dispute, it identifies the diverging execution step. Commitments are generated for memory, registers, CSR, and VM states across the execution trace, with disputed steps emulated within the EVM to resolve inconsistencies.

Ready to dive in? Keep reading or head over to the [Asterisc repo](https://github.com/protolambda/asterisc/tree/master).

## Getting started

1. Read through the [additional repo docs](https://github.com/protolambda/asterisc/tree/master/docs).
2. Use Foundry to compile the associated smart contracts.
3. Compile test binaries using the [`Makefile`](https://github.com/protolambda/asterisc/blob/master/tests/go-tests/Makefile).
4. Execute `rvgo` tests to validate both on-chain and off-chain operations through RISC-V unit tests.

## Key components

- **`rvgo`:** A Go-based RISC-V emulator with two operational modes:
  - **`Fast Mode`:** Executes one instruction per step on the VM state.
  - **`Slow Mode`:** Emulates one instruction per step using a VM state oracle.
- **`rvsol`:** A Solidity/Yul implementation of the slow-mode step for EVM compatibility.

### Yul in Solidity

Yul is chosen for its simplicity and precision, offering direct mirroring with Go code while retaining critical features like underflow/overflow behavior and untyped operations.

[See the repo](https://github.com/protolambda/asterisc/blob/master/README.md#why-use-yul-in-solidity) for a deeper dive on Yul and fast/slow modes.

## Supported RISC-V subsets

Here's a few key subsets. For the complete list, see the [repo](https://github.com/protolambda/asterisc?tab=readme-ov-file#risc-v-subset-support).
- `RV32I`: Base 32-bit instruction set
- `RV64I`: 64-bit instruction set
- `RV32M` and `RV64M`: Multiplication
- `RV32A` and `RV64A`: Atomics
- Compact instructions for Rust: Work in progress

Unsupported operations are implemented as no-ops, ensuring compatibility with the Go runtime.

## FAQ

The following section highlights specific advantages that Asterisc provides over other fault-proof systems.

### Benefits over Cannon

[Cannon](https://github.com/ethereum-optimism/cannon/), originally developed by [`geohot`](https://github.com/geohot/) and now maintained by Optimism, offers similar functionality but has key differences:
- Cannon operates on a 32-bit MIPS architecture, whereas Asterisc uses RISC-V.
- Asterisc supports 64-bit operations and deterministic threading, making it more future-ready.

### Benefits over Cartesi

[Cartesi](https://github.com/cartesi/) provides RISC-V fraud-proofing for a full machine, including numerous additional features. However, this added complexity can introduce risks. Asterisc focuses on simplicity by running single-process executions with minimal system calls.

### Benefits over WebAssembly

Arbitrum’s WebAssembly-based fraud-proofing leverages a business-source license and transformation to WAVM, limiting its general usability. In contrast, Asterisc is open-source under the MIT license, offering broader applicability.

## Contributing

Asterisc is designed to run Go programs for fraud-proofing optimistic rollups. Contributions that align with its goals of simplicity, minimalism, and compatibility are highly encouraged.